#
# report_tables.py
#
# As part of the `reports/` cleanup, this PR will create a bunch of new tables
# in `reports/tables` which:
#   1. Will be included in the Babel publication, and
#   2. Will be included in the GitHub repository in the `releases/` directory by version number, so that we can
#      compare between them automatically.
#
# So they will be intended to provide an at-a-glance view of what is currently in Babel.
#
# To simplify generating these files, this Python script won't calculate any numbers -- those should be generated
# as JSON files by `src/reports/duckdb_reports.py` and other scripts in `src/reports`. This Python script will just
# summarize those reports.
#
import csv
import json
from collections import defaultdict


def generate_prefix_table(prefix_report_json: str, prefix_report_table_csv: str):
    """
    The prefix table lists all the prefixes in the Babel outputs.

    :param prefix_report_json: The prefix report JSON file generated by `src/reports/duckdb_reports.py`.
    :param prefix_report_table_csv: The report table CSV file to generate.
    """

    with open(prefix_report_json, 'r') as f:
        prefix_report = json.load(f)

    curie_entries = []
    for prefix, inner in prefix_report.items():
        filename_entries = dict()

        for filename, entry in inner.items():
            if filename in filename_entries:
                raise ValueError(f"Duplicate filename {filename} for prefix {prefix}!")

            filename_entries[filename] = {
                'prefix': prefix,
                'curie_count': entry['curie_count'],
                'curie_distinct_count': entry['curie_distinct_count'],
            }

        if '_totals' not in filename_entries:
            raise ValueError(f"No totals entry for prefix {prefix}!")

        sorted_entries = sorted(filename_entries.items(), key=lambda x: x[1]['curie_distinct_count'], reverse=True)
        filename_rows = []
        for filename, entry in sorted_entries:
            if filename == '_totals':
                continue

            if entry['curie_count'] == entry['curie_distinct_count']:
                filename_rows.append(f"- {filename}: {entry['curie_count']:,} CURIEs")
            else:
                filename_rows.append(f"- {filename}: {entry['curie_count']:,} CURIEs ({entry['curie_distinct_count']:,} distinct)")

        curie_entries.append({
            'prefix': prefix,
            'curie_count': filename_entries['_totals']['curie_count'],
            'curie_distinct_count': filename_entries['_totals']['curie_distinct_count'],
            'filenames': "\n".join(filename_rows),
        })

    # Before writing it out, sort by distinct CURIE count descending.
    with open(prefix_report_table_csv, 'w') as f:
        writer = csv.DictWriter(f, [
            'Prefix',
            'CURIE count',
            'Distinct CURIE count',
            'Filenames'
        ])
        writer.writeheader()

        for entry in sorted(curie_entries, key=lambda x: x['curie_distinct_count'], reverse=True):
            row = {
                'Prefix': entry['prefix'],
                'CURIE count': "{:,}".format(entry['curie_count']),
                'Distinct CURIE count': "{:,}".format(entry['curie_distinct_count']),
                'Filenames': entry['filenames'],
            }

            writer.writerow(row)
